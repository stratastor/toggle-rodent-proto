syntax = "proto3";

package rodent;

option go_package = "github.com/stratastor/toggle-rodent-proto/proto";

// RodentService defines the gRPC service for Toggle-Rodent communication
service RodentService {
  // Register allows a Rodent node to register with Toggle
  // Authentication is handled via JWT token in request metadata
  rpc Register(RegisterRequest) returns (RegisterResponse);
  
  // Connect establishes a long-lived bidirectional connection
  // This is the primary channel for all communication after registration
  // Toggle will send commands over this stream and Rodent will respond
  // Status/heartbeat information should be sent as responses to Toggle's status requests
  rpc Connect(stream RodentRequest) returns (stream ToggleRequest);
  
  // SendEvents sends batched events to Toggle (unary RPC)
  // Uses JWT authentication via metadata
  // Returns acknowledgment for event processing status
  rpc SendEvents(EventBatch) returns (EventBatchResponse);
}

// RegisterRequest contains the information needed to register a Rodent node
// Note: Authentication and network type are handled via JWT token in metadata
message RegisterRequest {
  // System information about the registering node
  SystemInfo system_info = 1;
  
  // Reserved fields (2-10) for future expansion without breaking changes
  reserved 2 to 10;
}

// RegisterResponse contains the registration result
message RegisterResponse {
  bool success = 1;
  string message = 2;
  string domain = 3;
  string certificate = 4;
  string private_key = 5;
  string expires_on = 6;
}

// SystemInfo contains system statistics and health information
message SystemInfo {
  double cpu_usage = 1;
  double memory_usage = 2;
  double disk_usage = 3;
  repeated string warnings = 4;
  repeated string errors = 5;
}

// RodentRequest is sent from Rodent to Toggle
message RodentRequest {
  string request_id = 1;
  oneof payload {
    CommandResponse command_response = 2;
    EventNotification event = 3;
    Acknowledgement ack = 4;
  }
}

// ToggleRequest is sent from Toggle to Rodent
message ToggleRequest {
  string request_id = 1;
  oneof payload {
    CommandRequest command = 2;
    ConfigUpdate config = 3;
    Acknowledgement ack = 4;
  }
}

// CommandRequest represents a command sent to a Rodent node
message CommandRequest {
  string command_type = 1; // E.g., "zfs.dataset.create", "ad.user.add", "system.status"
  string target = 2;       // Target resource
  bytes payload = 3;       // JSON-encoded command parameters
  // The "system.status" command_type should be used by Toggle to request 
  // status/heartbeat information instead of having Rodent initiate heartbeats
}

// CommandResponse is the response to a CommandRequest
message CommandResponse {
  string request_id = 1;   // Matches the request
  bool success = 2;
  string message = 3;
  bytes payload = 4;       // JSON-encoded response data
  
  // Error information when success = false
  RodentError error = 5;   // Structured error information
}

// RodentError represents a structured error from Rodent
// This matches the pkg/errors.RodentError structure
message RodentError {
  int32 code = 1;         // Error code (consistent with pkg/errors.ErrorCode)
  string domain = 2;      // Error domain (e.g., "ZFS", "SERVER", etc.)
  string message = 3;     // Error message
  string details = 4;     // Optional detailed error explanation
  int32 http_status = 5;  // Applicable HTTP Status code
  
  // Additional error metadata
  map<string, string> metadata = 6;  // Metadata map for additional context
}

// EventNotification represents an event from Rodent
message EventNotification {
  string event_type = 1;   // E.g., "zfs.dataset.created", "ad.user.added"
  string source = 2;       // Source of the event
  int64 timestamp = 3;     // Unix timestamp in milliseconds
  bytes payload = 4;       // JSON-encoded event data
}

// ConfigUpdate allows Toggle to push configuration changes to Rodent
message ConfigUpdate {
  string config_type = 1;  // E.g., "logging", "monitoring"
  bytes payload = 2;       // JSON-encoded configuration
}

// Acknowledgement is used to confirm receipt of messages
message Acknowledgement {
  string request_id = 1;
  bool success = 2;
  string message = 3;
}

// Event batch for efficient transmission
message EventBatch {
  repeated Event events = 1;
  int64 batch_timestamp = 2;  // When batch was created
  string batch_id = 3;        // Unique batch identifier for deduplication
}

// Individual event structure
message Event {
  string event_id = 1;        // Unique event identifier
  string event_type = 2;      // e.g., "storage.dataset.created"
  EventLevel level = 3;       // severity level
  EventCategory category = 4; // domain category
  string source = 5;          // source module/component
  int64 timestamp = 6;        // Unix timestamp in milliseconds
  bytes payload = 7;          // JSON-encoded structured payload (see events.proto)
  map<string, string> metadata = 8; // Additional context

  // Reserved fields for future structured event types (optional enhancement)
  reserved 9 to 20;
}

// Event severity levels
enum EventLevel {
  EVENT_LEVEL_UNSPECIFIED = 0;
  EVENT_LEVEL_INFO = 1;
  EVENT_LEVEL_WARN = 2;
  EVENT_LEVEL_ERROR = 3;
  EVENT_LEVEL_CRITICAL = 4;
}

// Event domain categories
enum EventCategory {
  EVENT_CATEGORY_UNSPECIFIED = 0;
  EVENT_CATEGORY_SYSTEM = 1;
  EVENT_CATEGORY_STORAGE = 2;
  EVENT_CATEGORY_NETWORK = 3;
  EVENT_CATEGORY_SECURITY = 4;
  EVENT_CATEGORY_SERVICE = 5;
  EVENT_CATEGORY_IDENTITY = 6;      // AD/LDAP user/group/computer management
  EVENT_CATEGORY_ACCESS = 7;        // ACL, permissions, access control
  EVENT_CATEGORY_SHARING = 8;       // SMB/NFS shares, connections
}

// Response for event batch processing
message EventBatchResponse {
  bool success = 1;           // Simple success/failure
  string message = 2;         // Optional error message
}

